---
const TITLE = '贪吃蛇'
---
<div class="content-site" style="padding: 12px">
  <div id="snake-game" style="max-width: 960px; margin: 0 auto; display: flex; gap: 16px; align-items: flex-start; font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Noto Sans SC', 'Microsoft Yahei', sans-serif">
    <canvas id="snake-canvas" width={32 * 24} height={20 * 24} style="flex: 1; width: 100%; height: auto; border-radius: 8px; background: transparent"></canvas>
    <div style="min-width: 120px; display: flex; flex-direction: column; align-items: flex-end; gap: 8px">
      <span id="snake-score" style="font-weight: 600">分数 0</span>
    </div>
  </div>
</div>
<script is:inline>
(() => {
  let running = false;
  const size = 24;
  const cols = 32;
  const rows = 20;
  let last = 0;
  const speed = 140;
  const canvas = document.getElementById('snake-canvas');
  const scoreEl = document.getElementById('snake-score');
  function rand(){ return { x: Math.floor(Math.random()*cols), y: Math.floor(Math.random()*rows) }; }
  let target = { x: Math.floor(cols/2) + 1, y: Math.floor(rows/2) };
  let snake = [{ x: Math.floor(cols/2), y: Math.floor(rows/2) }];
  let maxLen = 1;
  let food = rand();
  let score = 0;
  let active = false;
  let blink = false;
  let blinkLast = 0;
  const blinkInterval = 500;
  function reset(){ running = true; snake = [{ x: Math.floor(cols/2), y: Math.floor(rows/2) }]; maxLen = 1; score = 0; scoreEl.textContent = '分数 ' + score; active = false; target = { x: Math.floor(cols/2) + 1, y: Math.floor(rows/2) }; food = rand(); }
  function clamp(v, min, max){ return v < min ? min : (v > max ? max : v); }
  function step(t){
    if (!running) { requestAnimationFrame(step); return; }
    if (t - last < speed) { requestAnimationFrame(step); return; }
    last = t;
    if (t - blinkLast >= blinkInterval) { blink = !blink; blinkLast = t; }
    const hx = snake[0].x;
    const hy = snake[0].y;
    const dx = active ? Math.sign(target.x - hx) : 0;
    const dy = active ? Math.sign(target.y - hy) : 0;
    const nx = clamp(hx + dx, 0, cols - 1);
    const ny = clamp(hy + dy, 0, rows - 1);
    const head = { x: nx, y: ny };
    const ate = head.x === food.x && head.y === food.y;
    if (ate) { maxLen += 1; food = rand(); }
    snake.unshift(head);
    while (snake.length > maxLen) snake.pop();
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, cols * size, rows * size);
    ctx.strokeStyle = '#d1d5db';
    ctx.lineWidth = 1;
    for (let x = 0; x <= cols; x++) { ctx.beginPath(); ctx.moveTo(x * size, 0); ctx.lineTo(x * size, rows * size); ctx.stroke(); }
    for (let y = 0; y <= rows; y++) { ctx.beginPath(); ctx.moveTo(0, y * size); ctx.lineTo(cols * size, y * size); ctx.stroke(); }
    ctx.fillStyle = '#f97316';
    ctx.fillRect(food.x * size + 2, food.y * size + 2, size - 4, size - 4);
    ctx.save();
    ctx.globalAlpha = (dx !== 0 || dy !== 0) ? 1 : (blink ? 0.55 : 1);
    ctx.fillStyle = '#4ade80';
    snake.forEach(s => ctx.fillRect(s.x * size + 2, s.y * size + 2, size - 4, size - 4));
    ctx.restore();
    if (ate) { score += 1; scoreEl.textContent = '分数 ' + score; }
    requestAnimationFrame(step);
  }
  function onMove(e){
    const r = canvas.getBoundingClientRect();
    const scaleX = canvas.width / r.width;
    const scaleY = canvas.height / r.height;
    const mx = (e.clientX - r.left) * scaleX;
    const my = (e.clientY - r.top) * scaleY;
    const gx = clamp(Math.floor(mx / size), 0, cols - 1);
    const gy = clamp(Math.floor(my / size), 0, rows - 1);
    target = { x: gx, y: gy };
    active = true;
  }
  function onEnter(){ active = true; }
  function onLeave(){ active = false; }
  reset();
  canvas.addEventListener('pointermove', onMove);
  canvas.addEventListener('pointerenter', onEnter);
  canvas.addEventListener('pointerleave', onLeave);
  requestAnimationFrame(step);
})();
</script>
