---
const TITLE = '沙子俄罗斯方块';
---
<div class="content-site" style="padding: 12px">
  <div id="sand-tetris" style="max-width: 960px; margin: 0 auto; display: flex; gap: 0; align-items: center; justify-content: center; font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Noto Sans SC', 'Microsoft Yahei', sans-serif">
    <div id="board-wrap" style="position: relative; display: inline-block">
      <div id="score" style="position: absolute; z-index: 10; top: 4px; left: 4px; font-size: 13px; font-weight: 700; color: #111827; background: rgba(255,255,255,0.7); padding: 2px 6px; border-radius: 4px">分数 0</div>
      <canvas id="tetris-canvas" width={300} height={300} style="flex: 0 0 auto; width: clamp(346px, 95vw, 461px); aspect-ratio: 10 / 13; height: auto; border-radius: 8px; background: transparent; image-rendering: pixelated"></canvas>
      <div id="palette" style="position: absolute; left: calc(100% + 2px); top: 50%; transform: translateY(-50%); min-width: 200px; display: flex; flex-direction: column; gap: 6px">
        <div style="display: flex; flex-direction: column; align-items: center; gap: 8px">
          <svg class="shape-preview" width="64" height="64" viewBox="0 0 16 16" style="background: #0b1020; border-radius: 6px"></svg>
          <svg class="shape-preview" width="64" height="64" viewBox="0 0 16 16" style="background: #0b1020; border-radius: 6px"></svg>
          <svg class="shape-preview" width="64" height="64" viewBox="0 0 16 16" style="background: #0b1020; border-radius: 6px"></svg>
        </div>
        <div style="margin-top: 4px; font-size: 12px; color: #111827; line-height: 1.6; font-weight: 600">拖动右侧方块到左侧面板以落下</div>
      </div>
    </div>
  </div>
  <style>
    #sand-tetris:has(#tetris-canvas:focus) { outline: none; }
  </style>
</div>
<script is:inline>
(() => {
  const canvas = document.getElementById('tetris-canvas');
  const previews = Array.from(document.querySelectorAll('.shape-preview'));
  const ctx = canvas.getContext('2d');
  const UNIT = 8;
  const TW = 10;
  const TH = 13;
  const px = 1;
  const W = TW * UNIT;
  const H = TH * UNIT;
  let SCALEX = 1, SCALEY = 1;
  function updateCanvasResolution(){
    const r = canvas.getBoundingClientRect();
    const dpi = window.devicePixelRatio || 1;
    canvas.width = Math.floor(r.width * dpi);
    canvas.height = Math.floor(r.height * dpi);
    ctx.setTransform(dpi, 0, 0, dpi, 0, 0);
    SCALEX = r.width / W;
    SCALEY = r.height / H;
  }
  updateCanvasResolution();
  window.addEventListener('resize', updateCanvasResolution);
  const colors = ['#ef4444','#22c55e','#3b82f6','#f59e0b'];
  function hexToRgb(hex){ hex = hex.replace('#',''); if(hex.length===3){ hex = hex.split('').map(c=>c+c).join(''); } const num=parseInt(hex,16); return { r:(num>>16)&255, g:(num>>8)&255, b:num&255 } }
  function rgbToHex(r,g,b){ const to = (v)=>{ v=Math.max(0,Math.min(255,Math.round(v))); return v.toString(16).padStart(2,'0') }; return '#' + to(r) + to(g) + to(b) }
  function shadeHex(hex, p){ const {r,g,b}=hexToRgb(hex); const fn=(v)=> p>=0 ? v + (255 - v) * p : v * (1 + p); return rgbToHex(fn(r), fn(g), fn(b)) }
  function randomShade(hex){ return shadeHex(hex, (Math.random()*0.12 - 0.06)) }
  let running = true;
  let last = 0;
  let score = 0;
  function rand(n){ return Math.floor(Math.random()*n); }
  function clamp(v,min,max){ return v<min?min:(v>max?max:v); }
  class Display{
    constructor(w,h){ this.w=w; this.h=h; this.grid=new Array(w*h).fill(null); }
    idx(x,y){ return y*this.w+x; }
    get(x,y){ if(x<0||y<0||x>=this.w||y>=this.h) return null; return this.grid[this.idx(x,y)]; }
    set(x,y,v){ if(x<0||y<0||x>=this.w||y>=this.h) return; this.grid[this.idx(x,y)]=v; }
    clear(x,y){ if(x<0||y<0||x>=this.w||y>=this.h) return; this.grid[this.idx(x,y)]=null; }
  }
  class Sand{
    constructor(x,y,baseColor,visualColor){ this.x=x; this.y=y; this.base=baseColor; this.color=visualColor ?? baseColor; this.blink=0; this.blinking=false; }
    update(display){
      if(this.blinking) return;
      const x=this.x, y=this.y;
      if(y+1>=H) return;
      if(!display.get(x,y+1)){ display.clear(x,y); this.y=y+1; display.set(this.x,this.y,this); return; }
      const r=Math.random()<0.5;
      if(r){ if(x-1>=0 && y+1<H && !display.get(x-1,y+1)){ display.clear(x,y); this.x=x-1; this.y=y+1; display.set(this.x,this.y,this); return; } }
      else { if(x+1<W && y+1<H && !display.get(x+1,y+1)){ display.clear(x,y); this.x=x+1; this.y=y+1; display.set(this.x,this.y,this); return; } }
      if(x-1>=0 && y+1<H && !display.get(x-1,y+1)){ display.clear(x,y); this.x=x-1; this.y=y+1; display.set(this.x,this.y,this); return; }
      if(x+1<W && y+1<H && !display.get(x+1,y+1)){ display.clear(x,y); this.x=x+1; this.y=y+1; display.set(this.x,this.y,this); return; }
    }
  }
  const shapes = [
    [[1,1,1,1]],
    [[1,1],[1,1]],
    [[0,1,0],[1,1,1]],
    [[1,0,0],[1,1,1]],
    [[0,0,1],[1,1,1]],
    [[0,1,1],[1,1,0]],
    [[1,1,0],[0,1,1]],
  ];
  function rotate(m){ const h=m.length,w=m[0].length; const r=new Array(w).fill(0).map(()=>new Array(h).fill(0)); for(let y=0;y<h;y++) for(let x=0;x<w;x++) r[x][h-1-y]=m[y][x]; return r; }
  class Block{
    constructor(mat,color){ this.mat=mat; this.color=color; this.x=0; this.y=0; }
    collides(display,dxCells,dyCells,mat){ const m=mat||this.mat; for(let cy=0;cy<m.length;cy++) for(let cx=0;cx<m[0].length;cx++) if(m[cy][cx]){
        for(let py=0;py<UNIT;py++) for(let px2=0;px2<UNIT;px2++){
          const gx=(this.x+cx+dxCells)*UNIT+px2; const gy=(this.y+cy+dyCells)*UNIT+py;
          if(gx<0||gy<0||gx>=W||gy>=H) return true;
          const o=display.get(gx,gy); if(o) return true;
        }
      } return false; }
    move(display,dx,dy){ if(!this.collides(display,dx,dy)) { this.x+=dx; this.y+=dy; return true; } return false; }
    rotate(display){ const r=rotate(this.mat); if(!this.collides(display,0,0,r)) this.mat=r; }
    lock(display){ for(let cy=0;cy<this.mat.length;cy++) for(let cx=0;cx<this.mat[0].length;cx++) if(this.mat[cy][cx]){
        for(let py=0;py<UNIT;py++) for(let px2=0;px2<UNIT;px2++){
          const gx=(this.x+cx)*UNIT+px2; const gy=(this.y+cy)*UNIT+py; if(gy>=0&&gy<H){ const s=new Sand(gx,gy,this.color,randomShade(this.color)); display.set(gx,gy,s); }
        }
      } }
  }
  class Game{
    constructor(){ this.display=new Display(W,H); this.sands=[]; this.flashGroups=[]; this.dragging=false; this.dragShape=null; this.dragColor=null; this.hoverX=0; this.dragIndex=-1; this.dropActive=false; this.dropBlock=null; this.dropSpeed=1; this.dropDelayFrames=3; this.dropCooldown=0; }
    hardDropBlock(mat,color,x){ const b=new Block(mat,color); b.x=x; b.y=0; while(b.move(this.display,0,1)); b.lock(this.display); this.collectSands(); }
    startDropBlock(mat,color,x){ const b=new Block(mat,color); b.x=x; b.y=0; this.dropBlock=b; this.dropActive=true; }
    tick(){
      if(this.dropActive && this.dropBlock){
        if(this.dropCooldown > 0){
          this.dropCooldown -= 1;
        } else {
          const moved = this.dropBlock.move(this.display,0,1);
          this.dropCooldown = this.dropDelayFrames;
          if(!moved){
            this.dropBlock.lock(this.display);
            this.dropBlock=null;
            this.dropActive=false;
          }
        }
      }
      this.collectSands();
      this.updateSands();
      this.checkEliminate();
      this.collectSands();
    }
    collectSands(){ this.sands.length=0; for(let y=0;y<H;y++) for(let x=0;x<W;x++){ const s=this.display.get(x,y); if(s instanceof Sand) this.sands.push(s); } }
    updateSands(){ for(let i=0;i<this.sands.length;i++) this.sands[i].update(this.display); }
    checkEliminate(){
      const vis=new Array(W*H).fill(false);
      const groups=[];
      for(let y=0;y<H;y++) for(let x=0;x<W;x++){
        const s=this.display.get(x,y); if(!(s instanceof Sand) || s.blinking || vis[y*W+x]) continue;
        const color=(s.base ?? s.color); const q=[[x,y]]; vis[y*W+x]=true; const nodes=[]; let touchL=false, touchR=false;
        while(q.length){ const [cx,cy]=q.pop(); nodes.push([cx,cy]); if(cx===0) touchL=true; if(cx===W-1) touchR=true; for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++){ if(dx===0&&dy===0) continue; const nx=cx+dx, ny=cy+dy; if(nx<0||ny<0||nx>=W||ny>=H) continue; const s2=this.display.get(nx,ny); const id=ny*W+nx; if(!(s2 instanceof Sand) || vis[id]) continue; const c2=(s2.base ?? s2.color); if(c2!==color) continue; vis[id]=true; q.push([nx,ny]); }
        }
        if(touchL && touchR) groups.push({nodes,color});
      }
      if(groups.length){ for(const g of groups){ for(const [x,y] of g.nodes){ const s=this.display.get(x,y); if(s){ s.blinking=true; s.blink=30; } } this.flashGroups.push(g); }
      }
      for(const g of this.flashGroups){ let allDone=true; for(const [x,y] of g.nodes){ const s=this.display.get(x,y); if(s){ s.blink--; if(s.blink<=0){ this.display.clear(x,y); } else { allDone=false; } } }
        if(allDone){ score += g.nodes.length; const se = document.getElementById('score'); if(se) se.textContent = '分数 ' + score; }
      }
      this.flashGroups=this.flashGroups.filter(g=>{ for(const [x,y] of g.nodes){ const s=this.display.get(x,y); if(s && s.blink>0) return true; } return false; });
    }
    draw(){ ctx.clearRect(0,0,canvas.width,canvas.height);
      const drawPixel=(x,y,color,alpha=1)=>{ ctx.save(); ctx.globalAlpha=alpha; ctx.fillStyle=color; ctx.fillRect(x*SCALEX, y*SCALEY, SCALEX, SCALEY); ctx.restore(); };
      for(let y=0;y<H;y++) for(let x=0;x<W;x++){ const s=this.display.get(x,y); if(s instanceof Sand){ const a=s.blinking ? ((s.blink%10)<5 ? 0.3 : 1) : 1; drawPixel(x,y,s.color,a); } }
      if(this.dropActive && this.dropBlock){ const m=this.dropBlock.mat; for(let cy=0;cy<m.length;cy++) for(let cx=0;cx<m[0].length;cx++) if(m[cy][cx]){
        const bx=(this.dropBlock.x+cx)*UNIT; const by=(this.dropBlock.y+cy)*UNIT;
        const rx=bx*SCALEX, ry=by*SCALEY, rw=UNIT*SCALEX, rh=UNIT*SCALEY;
        ctx.save();
        ctx.fillStyle=this.dropBlock.color;
        ctx.fillRect(rx, ry, rw, rh);
        ctx.globalAlpha=0.15; ctx.fillStyle='#ffffff'; ctx.fillRect(rx, ry, rw, rh/3);
        ctx.globalAlpha=0.12; ctx.fillStyle='#000000'; ctx.fillRect(rx, ry+rh*2/3, rw, rh/3);
        ctx.globalAlpha=1; ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.lineWidth=Math.max(0.5, Math.min(rw, rh)*0.05); ctx.strokeRect(rx, ry, rw, rh);
        ctx.restore();
      } }
      if(this.dragging && this.dragShape){ const m=this.dragShape; for(let cy=0;cy<m.length;cy++) for(let cx=0;cx<m[0].length;cx++) if(m[cy][cx]){
        const bx=(this.hoverX+cx)*UNIT; const by=(0+cy)*UNIT;
        const rx=bx*SCALEX, ry=by*SCALEY, rw=UNIT*SCALEX, rh=UNIT*SCALEY;
        ctx.save();
        ctx.globalAlpha=0.85; ctx.fillStyle=this.dragColor; ctx.fillRect(rx, ry, rw, rh);
        ctx.globalAlpha=0.25; ctx.fillStyle='#ffffff'; ctx.fillRect(rx, ry, rw, rh/3);
        ctx.globalAlpha=0.18; ctx.fillStyle='#000000'; ctx.fillRect(rx, ry+rh*2/3, rw, rh/3);
        ctx.globalAlpha=0.85; ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.lineWidth=Math.max(0.5, Math.min(rw, rh)*0.05); ctx.strokeRect(rx, ry, rw, rh);
        ctx.restore();
      } }
      ctx.save();
      const bx = W * SCALEX;
      const by = H * SCALEY;
      const lw = 3;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, bx, lw);          // top
      ctx.fillRect(0, by - lw, bx, lw);    // bottom
      ctx.fillRect(0, 0, lw, by);          // left
      ctx.fillRect(bx - lw, 0, lw, by);    // right
      ctx.restore();
    }
  }
  const game = new Game();
  function step(){ game.tick(); game.draw(); requestAnimationFrame(step); }
  function genItem(){ let mat=shapes[rand(shapes.length)]; for(let i=0;i<rand(4);i++) mat=rotate(mat); const color=colors[rand(colors.length)]; return { mat, color }; }
  function drawPreviewSVG(svg,item){ const cell=4; const w=item.mat[0].length*cell; const h=item.mat.length*cell; const ox=Math.floor((16 - w)/2); const oy=Math.floor((16 - h)/2); svg.setAttribute('viewBox','0 0 16 16'); while(svg.firstChild) svg.removeChild(svg.firstChild); for(let y=0;y<item.mat.length;y++) for(let x=0;x<item.mat[0].length;x++) if(item.mat[y][x]){ const r=document.createElementNS('http://www.w3.org/2000/svg','rect'); r.setAttribute('x', String(ox+x*cell)); r.setAttribute('y', String(oy+y*cell)); r.setAttribute('width', String(cell)); r.setAttribute('height', String(cell)); r.setAttribute('fill', item.color); r.setAttribute('stroke', '#ffffff'); r.setAttribute('stroke-width', '0.6'); r.setAttribute('stroke-opacity', '0.6'); svg.appendChild(r); } }
  let palette = [genItem(), genItem(), genItem()];
  previews.forEach((el,i)=> drawPreviewSVG(el, palette[i]));
  previews.forEach((el,i)=>{
    el.addEventListener('pointerdown', (e) => { const item=palette[i]; game.dragging=true; game.dragShape=item.mat; game.dragColor=item.color; game.dragIndex=i; el.setPointerCapture(e.pointerId); });
  });
  document.addEventListener('pointermove', (e) => {
    if(!game.dragging) return; const r=canvas.getBoundingClientRect(); const gridScaleX = W / r.width; const mx=(e.clientX - r.left) * gridScaleX; let cellX=Math.floor(mx / UNIT); const shapeW=game.dragShape[0].length; cellX=clamp(cellX, 0, TW - shapeW); game.hoverX=cellX;
  });
  document.addEventListener('pointerup', (e) => {
    if(!game.dragging) return; const r=canvas.getBoundingClientRect(); const inside = e.clientX>=r.left && e.clientX<=r.right && e.clientY>=r.top && e.clientY<=r.bottom; if(inside){ game.startDropBlock(game.dragShape, game.dragColor, game.hoverX); palette[game.dragIndex] = genItem(); drawPreviewSVG(previews[game.dragIndex], palette[game.dragIndex]); game.dragging=false; game.dragShape=null; game.dragColor=null; game.dragIndex=-1; }
    // 若在棋盘外释放，不结束拖拽，方块将继续贴边悬停
  });
  
  requestAnimationFrame(step);
})();
</script>
